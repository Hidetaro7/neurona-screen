doctype html
html(lang="en")
  head
    title Socket.IO chat on App Engine
    meta(charset="utf-8")
    style.
        body {
            background: black;
        }
        #messages { list-style-type: none; margin: 0; padding: 0; }
        #messages li { padding: 5px 10px; background: #ddd; }
        #messages li:nth-child(odd) { background: #eee; }
        .heart {
            position; absolute;
            bottom: 0;
        }
  body
    .canvas
        canvas#canvas
    ul(id="messages")
    script(src="/socket.io/socket.io.js")
    script(src="https://code.jquery.com/jquery-1.11.1.js")
    script.
        const canvas = document.querySelector("#canvas");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const ctx = canvas.getContext("2d");
        
        const defaultFontSize = 62;
        let voices = [] // 投稿テキストが入る

        const hearts = [];
        class Heart {
            constructor(msg) {
                this.x = Math.random() * canvas.width - 20;
                this.y = canvas.height - 20;
                this.text = msg;
                this.opacity = 1
                this.vy = Math.random() * 3 + 0.01
            }
        }

      $(function () {
        var socket = io();
        socket.on('good emitted', function(msg){
            console.log(msg.id)
           hearts.push(new Heart(msg.text));
        });
        socket.on('chat message', function(msg){
           console.log(msg);
           createImage(msg.message)
        //-    if(!msg.centerd) {
        //-        createImage(msg.message)
        //-    }
           //$('#messages').append($('<li>').text(msg.message));
          // window.scrollTo(0, document.body.scrollHeight);
         });
      });

        const createImage = (msg) => {
            const _canvas = document.createElement("canvas");
            const _ctx = _canvas.getContext("2d");
            const textLength = msg.length;
            const rectangleSize = {
                w: defaultFontSize * 3,
                h: textLength * defaultFontSize + (defaultFontSize * 2)
            }
            _canvas.width = rectangleSize.w;
            _canvas.height = rectangleSize.h;
            _ctx.font = defaultFontSize + "px 'ヒラギノ明朝' , serif"
            Array.prototype.forEach.call(msg, function(s,i) {
                for(let j=0; j<2; j++) {
                    const randomColor = `hsl(${Math.random()*360},100%,90%)`;
                    _ctx.save()
                    //_ctx.globalCompositeOperation = "lighter"
                    _ctx.strokeStyle = randomColor;
                    const _r = Math.random() * .2 - .1;
                    _ctx.setTransform(Math.cos(_r), Math.sin(_r), -Math.sin(_r), Math.cos(_r), defaultFontSize + _r * 12, defaultFontSize * i + defaultFontSize + _r * 12);
                    _ctx.strokeText(s, 0,0);
                    _ctx.restore();
                }
            });
            
            voices.push({
                canvas: _canvas,
                height: rectangleSize.h,
                x: Math.random() * canvas.width,
                y: canvas.height
            })
        }


      const tick = () => {
        requestAnimationFrame(tick);
        ctx.fillStyle = "rgba(0,0,0,0.1)";
        ctx.fillRect(0,0,canvas.width, canvas.height)
        for(let i=0, l=voices.length; i<l; i++) {
            const p = voices[i];
            p.y -=2;
            ctx.drawImage(p.canvas, p.x, p.y);
        }

        voices = voices.filter(n => n.y > -n.height);

        console.log(voices.length)
        

        hearts.forEach((h, index) => {
            if(h.y < 0) {
                hearts.splice(index, 1)
            } else {
                ctx.save()
                h.y -= 2;
                
                ctx.font = "120px serif"
                ctx.fillStyle = "red"
                ctx.fillText(h.text, h.x, h.y)
                ctx.restore()
            }
        })
      }

      tick();
      